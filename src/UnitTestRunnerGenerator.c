/**
 * \file TestRunnerGenerator.c
 * \author vEmagic (admin@vemagic.com)
 * \brief 
 * \version 0.0.1
 * \date 2020-04-19
 * 
 * @copyright Copyright (c) 2020
 * 
 */

#include <stdio.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>
#include <stdlib.h>
#include <string.h>
// #include <unistd.h>
// #include <dirent.h>
// #include <sys/stat.h>
// #include <pthread.h>
#include "CCodeParse.h"
#include "GeneratorOutputPrivate.h"
#include "UnitTestRunnerGenerator.h"

// 打印测试组信息到标准输出
void PrintGroupMessage(struct _test_group_ **groupArray, int count)
{
    struct _test_group_ *group = *groupArray;
    fprintf(stdout, "\nGroup count: %d", count);
    for (int idx = 0; idx < count; ++idx)
    {
        fprintf(stdout, "\n%s: %d Functions\n", group[idx].group, group[idx].nameCount);
        for (int j = 0; j < group[idx].nameCount; ++j)
        {
            fprintf(stdout, "\t%s\n", group[idx].name[j]);
        }
    }
}

// 提取测试组信息
int RunnerGenerator_GetTestGroupAndTestname(char **test, int count, struct _test_group_ **groupArray)
{
    struct _test_group_ * group = NULL;
    int groupCount = 0;

    for (int idx = 0; idx < count; ++idx)
    {
        int len = 0;
        char *leftBracket = strchr(test[idx], '(');
        char *comma = strchr(test[idx], ',');
        char *rightBracket = strrchr(test[idx], ')');

        if (leftBracket && comma && rightBracket)
        {
            char *has = NULL;
            for (int i = 0; i < groupCount; ++i)
            {
                has = strstr(leftBracket + 1, group[i].group);
            }

            struct _test_group_ *testGroup = NULL;
            if (!has && ++groupCount &&
                (NULL != (group = (struct _test_group_ *)realloc(group, groupCount * sizeof(struct _test_group_)))))
            {
                testGroup = &group[groupCount - 1];
                memset(testGroup, 0, sizeof(struct _test_group_));
                len = comma - leftBracket;
                if (NULL != (testGroup->group = (char *)calloc(len, sizeof(char))))
                {
                    strncpy(testGroup->group, leftBracket + 1, len);
                    testGroup->group[len - 1] = '\0';
                }
            }

            if (group != NULL && groupCount > 0)
            {
                testGroup = &group[groupCount - 1];
                ++testGroup->nameCount;
                testGroup->name = (char **)realloc(testGroup->name, testGroup->nameCount * sizeof(char *));
                if (testGroup->name != NULL)
                {
                    char **testName = &testGroup->name[testGroup->nameCount - 1];
                    len = rightBracket - comma;
                    if (NULL != (*testName = (char *)calloc(len, sizeof(char))))
                    {
                        strncpy(*testName, comma + 1, len);
                        (*testName)[len - 1] = '\0';
                    }
                }
            }
        }
    }

    *groupArray = group;
    return groupCount;
}

// 释放测试数组信息所占内存
void RunnerGenerator_TestGroupAndTestnameDestory(struct _test_group_ **groupArray, int groupCount)
{
    for (int idx = 0; idx < groupCount; ++idx)
    {
        if ((*groupArray)[idx].group && (*groupArray)[idx].name)
        {
            free((*groupArray)[idx].group);
            (*groupArray)[idx].group = NULL;
            CCP_Free(&(*groupArray)[idx].name, &(*groupArray)[idx].nameCount);
        }
    }

    if (*groupArray != NULL)
    {    
        free(*groupArray);
        *groupArray = NULL;
    }
}

// 生成测试运行容器源文件
void RunnerGenerator_GeneratorRunnerFile(struct _test_group_ **groupArray, int groupCount, const char *fileName)
{
    // char *cwd = getcwd(NULL, 0);
    char *cwd = NULL;
    CCP_GetCwd(&cwd);
    char *outputPath = CCP_CombinePath(cwd, (char *)fileName);
    free(cwd);

    if (!CCP_IsFilePathVaild(outputPath))
        return;

    FILE *fp = fopen(outputPath, "w+");
    if (fp)
    {
        char *head = "#include \"unity_fixture.h\"";
        char *testRunner = "TEST_GROUP_RUNNER(";
        char *testCase = "\tRUN_TEST_CASE(";

        outputCFileGenerateMessage(fp, " * THE FILE IS GENERATED by TGen, DO NOT EDITE IT.\n");
        outputCFileHead(fp, &head, 1);
        outputCFileBlankLine(fp);
        for (int idx = 0; idx < groupCount; ++idx)
        {
            char *group = (*groupArray)[idx].group;
            outputCFileFunctionStart(fp, testRunner, &group, 1);

            for (int cnt = 0; cnt < (*groupArray)[idx].nameCount; ++cnt)
            {
                char *name = (*groupArray)[idx].name[cnt];
                char *args[2] = {group, name};
                outputCFileFunctionCall(fp, testCase, args, 2);
            }

            outputCFileFunctionEnd(fp, "}");
            outputCFileBlankLine(fp);
        }
        fclose(fp);
    }
    free(outputPath);
}

// 生成测试main文件
void RunnerGenerator_GeneratorMainFile(struct _test_group_ **groupArray, int groupCount, char *path, char *fileName)
{
    // char *cwd = getcwd(NULL, 0);
    char *cwd = NULL;
    CCP_GetCwd(&cwd);
    char *outputPath = CCP_CombinePath(cwd, (char *)fileName);
    free(cwd);

    if (CCP_IsFilePathVaild(outputPath))
    {
        FILE *fp = fopen(outputPath, "w+");
        if (fp)
        {
            char *head = "#include \"unity_fixture.h\"";
            char *RunTestGroup = "\tRUN_TEST_GROUP(";
            char *RunTestAll = "static void RunTestAll(void)";
            char *main = "int main(int argc, char *argv[])";
            char *unitymain = "\treturn UnityMain(argc, argv, RunTestAll);\n";
            size_t size = sizeof(char);

            outputCFileHead(fp, &head, 1);
            outputCFileBlankLine(fp);
            outputCFileFunctionStart(fp, RunTestAll, NULL, 0);
            for (int idx = 0; idx < groupCount; ++idx)
            {
                char *group = (*groupArray)[idx].group;
                outputCFileFunctionCall(fp, RunTestGroup, &group, 1);
            }
            outputCFileFunctionEnd(fp, "}");

            outputCFileBlankLine(fp);

            outputCFileFunctionStart(fp, main, NULL, 0);
            fwrite(unitymain, size, strlen(unitymain), fp);
            outputCFileFunctionEnd(fp, "}");

            fclose(fp);
        }
        free(outputPath);
    }
}
